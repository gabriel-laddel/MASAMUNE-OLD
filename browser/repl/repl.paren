(defvar -cc (@ -components classes)) 
(defvar -ci (@ -components interfaces)) 
(defvar loader (chain (aref -cc "@mozilla.org/moz/jssubscript-loader;1")
		      (get-service (@ -ci moz-i-j-s-sub-script-loader)))) 
(defvar util (create)) 
((@ loader load-sub-script) "file:///root/quicklisp/local-projects/masamune/browser/repl/util.js" util) 

(defvar -d-e-b-u-g f) 

(defun on-output ()
  (throw (new (-error "onInput callback must be assigned.")))) 

(defun on-quit ()
 (throw (new (-error "onQuit callback must be assigned.")))) 

(defun init (context)
  (defvar _this this)
  (setf (@ this _name) (choose-name "repl" context)
	(@ this _creation-context) context
	(@ this _host-context) context
	(@ this _work-context) context
	(aref (@ this _creation-context) (@ this _name)) this
	(@ this _context-history) (list)
	(@ this _input-buffer) ""
	(@ this _emergency-exit)
	(lambda (event) 
	  ((@ _this print) "Host context unloading! Going back to creation context.") ((@ _this home))))
  
  ((@ this __define-getter__) "repl" (lambda () (return this)))
  (setf (@ this _env) (create)
	(@ this _saved-env) (create))
  ((@ this setenv) "printPrompt" t)
  ((@ this setenv) "inputMode" "syntax")
  (setf (@ this _interactor-classes) (create)
	(@ this _interactor-stack) (list))
  ((@ this define-interactor) "javascript" javascript-interactor)
  (defvar default-interactor-class (aref (@ this _interactor-classes) "javascript"))
  (defvar default-interactor (new (default-interactor-class this)))
  (setf (@ this _interactor-stack) (list default-interactor))
  ((@ default-interactor on-start) this)) 

(defun setenv (name value)
  "Takes a name and a value and stores them so that they can be later retrieved via setenv(). Some, such as printPrompt boolean, affect there way the REPL works."
  (setf (aref (@ this _env) name) value)
  value) 

(defun getenv (name)
  "Given a name, returns a value previously stored via setenv()."
  (aref (@ this _env) name)) 

(defun pushenv ()
  "Takes one or more names of values previously stored via setenv(), and stores them so that they can be later restored via popenv()."
  (defvar name nil)
  (for ((i 0) (l (@ arguments length)))
       ((< i l)) ((incf i)) 
       (setf name (aref arguments i))
       (setf (aref (@ this _saved-env) name) (aref (@ this _env) name))))

(ps::inline-js "function popenv() {
    var name;
    for(var i=0, l=arguments.length; i<l; i++) {
        name = arguments[i];
        if(name in this._savedEnv) {
            this._env[name] = this._savedEnv[name];
            delete this._savedEnv[name];
        }
    }
}
popenv.doc ='Takes one or more names of values previously pushed via popenv() and restores them, overwriting the current ones.'")

;; (defun represent (thing)
;;   (setf represent (@ arguments callee)
;; 	s nil)
;;   (typecase thing
;;     (string " + thing + ")
;;     (number (setf s thing))
;;     (object (progn (setf names (array))
;; 		   (loop for name in thing
;; 			 do (push name names))
;; 		   (setf s thing)
;; 		   (when (> (length names) 0)
;; 		     (setf s (chain (+ s " - {" 
;; 				       (chain ((@ names slice) 0 7) 
;; 					      (map (lambda (n) (+ n ": " (try (cond ((null (aref thing n)) "null")
;; 									       ((equal "object" (type-of (aref thing n))) "{...}")
;; 									       (t (represent (aref thing n))))
;; 									 (:catch (e)  "[Exception!]")))))))
;; 				    (join ", ")))
;; 		     (when (> (length names) 7)
;; 		       (setf s (+ ", ...")))
;; 		     (setf (+ s "}")))))
;;     (function (setf s "function() {...}"))
;;     (t (setf s thing)))
;;   s)

(ps::inline-js
 "
function represent(thing) {
    var represent = arguments.callee;
    var s;
    switch(typeof(thing)) {
    case 'string':
        s = '\"' + thing + '\"';
        break;
    case 'number':
        s = thing;
        break;
    case 'object':
        var names = [];
        for(var name in thing)
            names.push(name);

        s = thing;
        if(names.length > 0) {
            s += ' - {';
            s += names.slice(0, 7).map(function(n) {
                var repr = n + ': ';
                try {
                    if(thing[n] === null)
                        repr += 'null';
                    else if(typeof(thing[n]) == 'object')
                        repr += '{...}';
                    else
                        repr += represent(thing[n]);
                } catch(e) {
                    repr += '[Exception!]'
                }
                return repr;
            }).join(', ');
            if(names.length > 7)
                s += ', ...'
            s += '}';
        }
        break;
    case 'function':
        s = 'function() {...}';
        break;
    default:
        s = thing;
    }
    return s;
}")

(defun print (data append-newline)
  ;; "Converts an object to a string and prints the string. Appends a newline
  ;; unless false is given as second parameter."
  ((@ this on-output) (if (equal data undefined) "
 " (+ data (if (equal append-newline f) "" "
")))))

(defun load (url arbitrary-context)
  "Loads a chrome:// or file:// script into the current context, or optionally into an arbitrary context passed as a second parameter."
  (try (return ((@ loader load-sub-script) url (or arbitrary-context (@ this _work-context))))
       (:catch nil)))

(defun enter (context wrapped)
  "Makes a new context the current one.  After this, new definitions (variables, functions etc.) will be members of the new context. Remembers the previous context, so that you can get back to it with leave()."
  (when (and (!= wrapped t) (!= (@ context wrapped-j-s-object) undefined))
    (setf context (@ context wrapped-j-s-object)))
  ((@ this _context-history push) (@ this _work-context))
  (when (is-top-level context)
    ((@ this _migrate-top-level) context))
  (setf (@ this _work-context) context)
  (@ this _work-context))

(defun back ()
  "Returns to the previous context."
  (when (setf context ((@ this _context-history pop)))
    (when (is-top-level context)
      ((@ this _migrate-top-level) context))
    (setf (@ this _work-context) context)
    (@ this _work-context)))

(defun home ()
  "Returns to the context where the REPL was created."
  ((@ this enter) (@ this _creation-context))) 

(defun quit ()
  "Ends the session."
  (and (chain ((@ this current-interactor)) on-stop) 
       (chain ((@ this current-interactor)) (on-stop this)))
  (delete (aref (@ this _host-context) (@ this _name)))
  (delete (aref (@ this _creation-context) (@ this _name)))
  ((@ this on-quit)))

(ps::inline-js "function rename(name) {
    if(name in this._hostContext)
        this.print('Sorry, name already exists in the context repl is hosted in.');
    else if(name in this._creationContext)
        this.print('Sorry, name already exists in the context was created.')
    else {
        delete this._creationContext[this._name];
        delete this._hostContext[this._name];
        this._name = name;
        this._creationContext[this._name] = this;
        this._hostContext[this._name] = this;
    }
}
rename.doc='Renames the session.'")

(ps::inline-js "function inspect(obj, maxDepth, name, curDepth) {
// adapted from ddumpObject() at
// http://lxr.mozilla.org/mozilla/source/extensions/sroaming/resources/content/transfer/utility.js

    function crop(string, max) {
        string = string.match(/^(.+?)(\n|$)/m)[1];
        max = max || 70;
        return (string.length > max-3) ?
            string.slice(0, max-3) + '...' : string;
    }

    if(name == undefined)
        name = '<' + typeof(obj) + '>';
    if(maxDepth == undefined)
        maxDepth = 0;
    if(curDepth == undefined)
        curDepth = 0;
    if(maxDepth != undefined && curDepth > maxDepth)
        return;

    var i = 0;
    for(var prop in obj) {
        if(obj instanceof Ci.nsIDOMWindow &&
           (prop == 'java' || prop == 'sun' || prop == 'Packages')) {
            this.print(name + '.' + prop + '=[not inspecting, either \"java\", \"sun\" or \"Packages\"]');
            continue;
        }

        try {
            i++;
            if(obj[prop] === null)
                this.print(name + '.' + prop + '=null');
            else if(typeof(obj[prop]) == 'object') {
                if(obj.length != undefined)
                    this.print(name + '.' + prop + '=[probably array, length '
                               + obj.length + ']');
                else
                    this.print(name + '.' + prop + '=[' + typeof(obj[prop]) + ']');

                this.inspect(obj[prop], maxDepth, name + '.' + prop, curDepth+1);
            }
            else if(typeof(obj[prop]) == 'function')
                this.print(name + '.' + prop + '=[function]');
            else if(typeof(obj[prop]) == 'xml') {
                let s = obj[prop].toXMLString().replace(/>\n\s*/g, ' ');
                this.print(name + '.' + prop + '=' + (s.length > 100 ? s.slice(0, 97) + '...' : s));
            }
            else
                this.print(name + '.' + prop + '=' + obj[prop]);

            if(obj[prop] && obj[prop].doc && typeof(obj[prop].doc) == 'string')
                this.print('    ' + crop(obj[prop].doc));

        } catch(e) {
            this.print(name + '.' + prop + ' - Exception while inspecting.');
        }
    }
    if(!i)
        this.print(name + \" is empty\");
}
inspect.doc = 'Lists members of a given object.'")

(defun look ()
  "Lists objects in the current context."
  ((@ this inspect) (@ this _work-context) 0 "this"))

(ps::inline-js "function highlight(context, time) {
    context = context || this._workContext;
    time = time || 1000;
    if(!context.QueryInterface)
        return;

    var NS_NOINTERFACE = 0x80004002;

    try {
        context.QueryInterface(Ci.nsIDOMXULElement);
        var savedBorder = context.style.border;
        context.style.border = 'thick dotted red';
        Cc['@mozilla.org/timer;1']
            .createInstance(Ci.nsITimer)
            .initWithCallback(
                {notify: function() {
                        context.style.border = savedBorder;
                    }}, time, Ci.nsITimer.TYPE_ONE_SHOT);
    } catch(e if e.result == NS_NOINTERFACE) {}
}
highlight.doc = 'Highlights the passed context (or the current, if none given) if it is a XUL element.'")

(defun where-am-i ()
  "Returns a string representation of the current context."
  (defvar context (@ this _work-context))
  (defvar  desc "")
  (incf desc context)
  (when (and (@ context document) (@ context document title))
    (incf desc (+ " - Document title: \"" (@ context document title) "\"")))
  (when (@ context node-name)
    (incf desc (+ " - " (@ context node-name))))
  ((@ this print) desc)) 

(defun search (criteria context)
  "Searches for a member in the current context, or optionally in an arbitrary given as a second parameter."
  (defvar context (or context (@ this _work-context)))
  (defvar matcher)
  (if (equal (typeof criteria) "function")
      (setf matcher criteria)
      (setf matcher (if (equal (typeof (@ criteria test)) "function")
			(lambda (name) (return ((@ criteria test) name)))
			(lambda (name) (return (equal name criteria))))))
  (for-in (name context) 
	  (when (matcher name) ((@ this print) name))))

(defun doc (thing)
  "Looks up documentation for a given object, either in the doc string (if present) or on XULPlanet.com."
  ((@ this print) ((@ util doc-for) thing))
  (setf url ((@ util help-url-for) thing))
  (when url
    ((@ this print) "Online help found, displaying...")
    (chain (aref -cc "@mozilla.org/embedcomp/window-watcher;1") 
	   (get-service (@ -ci ns-i-window-watcher))
	   (open-window nil url "help" (+ "width=640,height=600,scrollbars=yes,menubars=no,"
					  "toolbar=no,location=no,status=no,resizable=yes") nil)))) 

(defun reload-chrome ()
  "Reload all chrome packages"
  (try (chain (aref -cc "@mozilla.org/chrome/chrome-registry;1") 
	      (get-service (@ -ci ns-i-x-u-l-chrome-registry)) (reload-chrome)) (:catch nil)))

(defun define-interactor (name proto)
  "Defines a new interactor."
  (setf (aref (@ this _interactor-classes) name) (lambda () nil)
	(chain (aref (@ this _interactor-classes) name) prototype) proto)) 

(defun current-interactor ()
  (aref (@ this _interactor-stack)
	(- (@ this _interactor-stack length) 1))) 

(defun pop-interactor ()
  (when (equal (@ this _interactor-stack length) 1)
    (throw (new (-error "Cannot leave last interactor."))))
  (and (chain ((@ this current-interactor)) on-stop)
       (chain ((@ this current-interactor)) (on-stop this)))
  ((@ this _interactor-stack pop))
  (and (chain ((@ this current-interactor)) on-resume) 
       (chain ((@ this current-interactor)) (on-resume this)))) 

(defun push-interactor (interactor-name)
  (defvar interactor-class (aref (@ this _interactor-classes) interactor-name))
  (if (equal (typeof interactor-class) "undefined")
      (throw (new (-error (+ (+ "Interactor <" interactor-name) "> not defined."))))
      (progn
	(and (chain ((@ this current-interactor)) on-suspend) (chain ((@ this current-interactor)) (on-suspend this)))
	(setf new-interactor (new (interactor-class this)))
	((@ this _interactor-stack push) new-interactor)
	((@ new-interactor on-start) this)))) 
((@ push-interactor __define-getter__)
 "doc"
 (lambda ()
   (setf int-names (list))
   (for-in (int-name (@ this _interactor-classes)) ((@ int-names push) int-name))
   (return (+ (+ "Sets the current interactor. (Currently defined: \"" ((@ int-names join) "\", \"")) "\")"))))

(ps::inline-js "var javascriptInteractor = {
    onStart: function(repl) {
        debug('start');

        Cc['@mozilla.org/observer-service;1']
            .getService(Ci.nsIObserverService)
            .notifyObservers(null, 'startupcache-invalidate', null);

        this._inputBuffer = '';

        if(true) {
            repl.print('');
            repl.print('Welcome to MozRepl.');
            repl.print('');
            repl.print(' - If you get stuck at the ...> prompt, enter a semicolon (;) at the beginning of the line to force evaluation.');
            repl.print(' - If you get errors after every character you type, see http://github.com/bard/mozrepl/wikis/troubleshooting (short version: stop using Microsoft telnet, use netcat or putty instead)');
            repl.print('');
            repl.print('Current working context: ' + (repl._workContext instanceof Ci.nsIDOMWindow ?
                                                      repl._workContext.document.location.href :
                                                      repl._workContext));
            repl.print('Current input mode: ' + repl._env['inputMode']);

            repl.print('');
        }

        if(repl._name != 'repl') {
            repl.print('Hmmm, seems like other repls are running in repl context.');
            repl.print('To avoid conflicts, yours will be named ' + repl._name + '.');
        }

        repl._prompt();
    },

    onStop: function(repl) {},

    onSuspend: function(repl) {},

    onResume: function(repl) {},

    getPrompt: function(repl) {
        return repl._name + '> ';
    },

    handleInput: function(repl, input) {
        debug('input', input);

        if(input.match(/^\s*$/) && this._inputBuffer.match(/^\s*$/)) {
            repl._prompt();
            return;
        }

        var inputSeparators = {
            line:      /\n/m,
            multiline: /\n--end-remote-input\n/m,
        };

        function handleError(e) {
            var realException = (e instanceof LoadedScriptError ? e.cause : e);

            repl.print('!!! ' + realException + '\n');
            if(realException) {
                repl.print('Details:')
                repl.print();
                for(var name in realException) {
                    var content = String(realException[name]);
                    if(content.indexOf('\n') != -1)
                        content = '\n' + content.replace(/^(?!$)/gm, '    ');
                    else
                        content = ' ' + content;

                    repl.print('  ' + name + ':' + content.replace(/\s*\n$/m, ''));
                }
                repl.print();
            }

            repl._prompt();
        }

        switch(repl.getenv('inputMode')) {
        case 'line':
        case 'multiline':
            this._inputBuffer += input;
            var [chunk, rest] = scan(this._inputBuffer, inputSeparators[repl.getenv('inputMode')]);
            while(chunk) {
                try {
                    var result = repl.evaluate(chunk);
                    if(this != undefined)
                        repl.print(repl.represent(result));
                    repl._prompt();
                } catch(e) {
                    handleError(e);
                }

                [chunk, rest] = scan(rest, inputSeparators[repl.getenv('inputMode')]);
            }
            this._inputBuffer = rest;
            break;

        case 'syntax':
            if(/^\s*;\s*$/.test(input)) {
                try {
                    var result = repl.evaluate(this._inputBuffer);
                    if(result != undefined)
                        repl.print(repl.represent(result));
                    repl._prompt();
                } catch(e) {
                    handleError(e);
                }

                this._inputBuffer = '';
            } else {
                this._inputBuffer += input;
                try {
                    var result = repl.evaluate(this._inputBuffer);
                    if(result != undefined)
                        repl.print(repl.represent(result));
                    repl._prompt();
                    this._inputBuffer = '';
                } catch(e if e.name == 'SyntaxError') {
                    // ignore and keep filling the buffer
                    repl._prompt(repl._name.replace(/./g, '.') + '> ');
                } catch(e) {
                    handleError(e);
                    this._inputBuffer = '';
                }
            }
        }
    }
}")

(defun _migrate-top-level (context)
  (when (instanceof (@ this _host-context) (@ -ci ns-i-d-o-m-window))
    ((@ this _host-context remove-event-listener) "unload" (@ this _emergency-exit) f))
  (setf (aref (@ this _host-context) (@ this _name)) undefined
	(@ this _host-context) context
	(aref (@ this _host-context) (@ this _name)) this)
  (when (instanceof (@ this _host-context) (@ -ci ns-i-d-o-m-window))
    ((@ this _host-context add-event-listener) "unload" (@ this _emergency-exit) f))) 

(defun _prompt (prompt)
  (if ((@ this getenv) "printPrompt")
      (if prompt
          ((@ this print) prompt f)
          (if (equal (typeof (chain ((@ this current-interactor)) get-prompt)) "function")
              ((@ this print) (chain ((@ this current-interactor)) (get-prompt this)) f)
              ((@ this print) "> " f)))
      nil)) 

(defun _migrate-top-level (context)
  (when (instance-of (@ this _host-context) (@ -ci ns-i-d-o-m-window))
    (chain (@ this _host-context) (remove-event-listener "unload" (@ this _emergency-exit) f)))
  (setf (aref (@ this _host-context) (@ this _name)) undefined
	(@ this _host-context) context
	(aref (@ this _host-context) (@ this _name)) this)
  (when (instance-of (@ this _host-context) (@ -ci ns-i-d-o-m-window))
    (chain (@ this _host-context) (remove-event-listener "unload" (@ this _emergency-exit) f))))

(defun prompt (prompt)
  ((@ this print) "> " false)) 

(defun receive (input)
  (chain ((@ this current-interactor)) (handle-input this input)))

(defun debug ()
  (when -d-e-b-u-g
    (setf s (+ "D, MOZREPL : " (chain ((@ -array prototype slice call) arguments) (join " :: "))))
    (if (not ((@ s match) (regex "\\n$")))
	(incf s "\n")
	nil)
    (dump s)))

(ps::inline-js "function formatStackTrace(exception) {
    var trace = '';
    if(exception.stack) {
        var calls = exception.stack.split('\n');
        for each(var call in calls) {
            if(call.length > 0) {
                call = call.replace(/\\n/g, '\n');

                if(call.length > 200)
                    call = call.substr(0, 200) + '[...]\n';

                trace += call.replace(/^/mg, '\t') + '\n';
            }
        }
    }
    return trace;
}")

(ps::inline-js "
function chooseName(basename, context) {
    if(basename in context) {
        var i = 0;
        do { i++ } while(basename + i in context);
        return basename + i;
    } else
        return basename;
}")

(ps::inline-js "function isTopLevel(object) {
    return (object instanceof Ci.nsIDOMWindow ||
            'wrappedJSObject' in object ||
            'NSGetModule' in object ||
            'EXPORTED_SYMBOLS' in object ||
            (object.__parent__ && 'EXPORTED_SYMBOLS' in object.__parent__));
}")

(defun scan (string separator)
  (defvar match ((@ string match) separator))
  (if match
      (list ((@ string substring) 0 (@ match index))
	    ((@ string substr) (+ (@ match index) (chain (aref match 0) length))))
      (list nil string)))

(ps::inline-js "
function evaluate(code) {
    var _ = arguments.callee;
    if(typeof(_.TMP_FILE) == 'undefined') {
        _.TMP_FILE = Cc['@mozilla.org/file/directory_service;1']
            .getService(Ci.nsIProperties)
            .get('ProfD', Ci.nsIFile);
        _.TMP_FILE.append('mozrepl.tmp.js');

        _.TMP_FILE_URL = Cc['@mozilla.org/network/io-service;1']
            .getService(Ci.nsIIOService)
            .getProtocolHandler('file')
            .QueryInterface(Ci.nsIFileProtocolHandler)
            .getURLSpecFromFile(_.TMP_FILE);
    }

    var fos = Cc['@mozilla.org/network/file-output-stream;1']
        .createInstance(Ci.nsIFileOutputStream);
    fos.init(_.TMP_FILE, 0x02 | 0x08 | 0x20, 0600, 0);

    var os = Cc['@mozilla.org/intl/converter-output-stream;1']
        .createInstance(Ci.nsIConverterOutputStream);
    os.init(fos, 'UTF-8', 0, 0x0000);
    os.writeString(code);
    os.close();

    if(typeof(_.cacheKiller) == 'undefined')
        _.cacheKiller = 0;
    
    _.cacheKiller++;
    var scriptUrl = _.TMP_FILE_URL + '?' + _.cacheKiller;
    debug('evaluate', scriptUrl);
    var result = loader.loadSubScript(scriptUrl, this._workContext, 'UTF-8');

    this.$$ = result;
    return result;
}") 

(defun -loaded-script-error (cause) (setf (@ this cause) cause)) 
