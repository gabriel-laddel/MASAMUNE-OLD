#+TITLE: Masamune
#+STARTUP: overview
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="finishing-touches.css"/>

* Design
** Guiding Principles

There are many distros out there, why should you use this one?

1. [[https://glyph.twistedmatrix.com/2005/11/ethics-for-programmers-primum-non.html][It's yours]]. All the sources that can be included have been, along with the information necessary to bootstrap yourself into a complete understanding of the system.
   
2. Be robust. E.G., if you had the misfortune to end up in a totalitarian Marxist regime (USSA, circa 2015) Masamune should have the tools to aid you in getting out - with or without internet.
   
3. Common Lisp only. Other languages are not currently supported and will not be supported at any time in the future.
   
4. Expressive power before security and convenience.
   
See also, [[http://www.loper-os.org/?p=284][The Seven Laws of Sane Personal Computing]]

** Security

Unlike other linux systems Masamune has no concept of users, this is because the current security models are stupid. There is one user, root. Use strong passwords and don't store anything valuable on the machine.

Required reading:

[[http://www.loper-os.org/?p=288][On the Insanity of Computer (in)-Security]]
[[http://trilema.com/2013/snsa-first-product-the-cardano/][S.NSA first product - The Cardano]]
[[http://trilema.com/?p=49944&preview=true][Why I suspect Schneier is a US agent]]
[[http://www.loper-os.org/?p=1299][Don't Blame the Mice]]
[[http://trilema.com/2013/how-to-airgap-a-practical-guide/][How to airgap. A practical guide.]]
[[http://www.loper-os.org/?p=1441][Mechanics of FLUXBABBITT.]]
[[http://www.contravex.com/2014/11/28/breaking-a-bitcoin-brainwallet/][Breaking A Bitcoin Brainwallet]]

One result of this is that the directory structure is slightly different than what you may be accustomed to. your home directory is =/root/=.

The long-term plan is to offer a security model catered to those who plan to use their machine in the bitcoin economy, not so much as entertaining the notion of interacting with a fiat bank. This will probably have to wait until Masamune is 90% feature complete.

** VMs

Using Masamune though a VM will not be supported now or at anytime in the future.

** code freeze

- SBCL-1.1.18
- emacs-24.4
- Maxima-?
- conkeror & XULrunner versions are described in [[./browser/conkeror.lisp][conkeror.lisp]]

Feel free to argue the point that a different version of XYZ should be used instead. These were chosen because they all build on my boxen today without any issues.

All other (non CL) packages will be frozen to specific versions when I get around to abstracting over / replacing some of portage.

** Misc style comments

Instead of shadowing the name of e.g., Alexandria's `format-symbol', I'll append a '%' to the front to indicate a slight difference from expected behavior.

I've chosen to use the special variable convention introduced in Let over Lambda

#+BEGIN_QUOTE
A traditional naming convention in Common lisp is to prefix and postfix the names of special variables with asterisk characters. For example, we might've chosen to name our =temp-special= variable =*temp-special*=. Since this convention is almost like having another namespace for dynamic variables, diminishing their duality with lexical variables, this book does not follow it exactly.

The asterisks are merely convention and, fortunately Common Lisp does not enforce them. Not only can we leave the asterisks off special variable names, but we can add them to lexical variable names. Maybe it is a question of style. Which is the lesser fashion crime: lexical variables with asterisks or special variables without? I tend to think the less verbose of the two. Also, the names of lexical and special variables can be gensyms, a concept that transcends print names on symbols.

So, as mentioned, this book hijacks the usual asterisk convention. Instead of

Asterisked variable names indicate special variables.

this book uses

Asterisked variable names indicate special variables defined by the standard.

My largest motivation for dropping these variable names earmuffs is simple and subjective: I think they are annoying to type and make code look ugly. I will not go so far as to suggest you od this for your own programs, just mention that I have been leaving off the earmuffs for years and am very content with Common Lisp

Let over Lambda, pg. 74
#+END_QUOTE

You'll note that almost everything is in the =masamune= or =masamune-gui= package. Until it becomes clear the base set of abstractions don't need much more work I'm going to leave this.

*** TODO review common lisp style guides and codify
* Installing

You should have two computers available if you plan on installing Masamune as the machine you're installing it on will be without internet access at several points in the install process. The process is as follows.

Install funtoo linux using [[http://www.funtoo.org/Funtoo_Linux_Installation ][Funtoo install guide]] with the following modifications:

** Stage 3 tarball

I recommend using the latest funtoo-stable stage3 tarball until a specific version is locked in.

** Wifi

The install guide doesn't state it anywhere, but it as long as you use network manager it includes an ncurses gui for free and so you don't need to =addwifi -S wpa -K 'pass' network=.

#+BEGIN_SRC
emerge networkmanager
rc-update add NetworkManager default
#+END_SRC

Should suffice. =nmtui= is the shell command to launch the ncurses gui.

** post funtoo-install

NOTE: If you see a message like

"ModemManager[\\d]: <warn> Couldn't find support for device at '[a-zA-Z/0-9]*': not supported by any plugin"

you can probably ignore it. Press RET and you'll be able to login anyway.

Run the following bash commands. If you need wifi, run =nmtui=.

#+BEGIN_SRC bash
emerge git
emerge sbcl
cd ~/quicklisp/local-projects/ && git clone https://github.com/gabriel-laddel/masamune.git
sbcl --load ~/quicklisp/local-projects/masamune/build/cripple-mode-install.lisp
#+END_SRC

** Emacs and CL customizations

the files emacs-customizations.el and lisp-customizations.lisp get loaded at the end of the init process. think of it as a replacement for your .emacs and .sbclrc files.

** Debugging

=journalctl --no-pager=
http://jvns.ca/blog/2014/04/20/debug-your-programs-like-theyre-closed-source/

* TODOs
** TODO Uber browser search 

http://lifehacker.com/5971715/five-custom-searches-you-should-enable-in-your-browser-right-now

Sure! So I made a js scriptlet that can be used to enhance any normal search url with a lot more wildcards and hosted it here http://jsfiddle.net/mdegat01/WSLak/. Just like a normal search url you put the url at the front (replace the url variable with the new one you want) and put in wildcards for where you want dynamic text inserted. However, instead of just getting %s afterwards you get 7 now:

%e = enterred text (except ending w, t, or c)

%h = highlighted text on page

%q = search string (equivalent to (%h %e).trim())

%d = domain of current page

%u = full url of current page

%t = title of current page

%l = current location (format is '{curr lat} {curr long}')

This allows you to make some pretty nifty search engines. Here are some of the first examples I made to test if everything was working:

www[dot]google[dot]com/maps?q=%q%20near%20%l

Map all things that match {typed or highlighted text} near me now

www[dot]google[dot]com/maps?saddr=%l&daddr=%q

Give me directions from where I am now to {typed or highlighted text}

www[dot]downforeveryoneorjustme[dot]com/%(q||d)

Check if the site is down. That's a fallback ||, javascript style, basically use what I

typed/highlighted or (if nothing is enterred) use the current domain

www[dot]google[dot]com/search?q=cache:%u

Visit google's cache of the current page if it's down

www[dot]google[dot]com/search?q=site:%d%20%q

Highlight or type text and search it on the current domain via google

www[dot]google[dot]com/calendar/event?ctext=%qâˆ¾tion=TEMPLATE&pprop=HowCreated:QUICKADD

Highlight or type text and have it quick added as a google calendar event

www[dot]urlvoid[dot]com/scan/%(h||u)

Hopefully highlight and scan a url but if you already went to it scan that instead

Additionally, even this is useful:

{Any normal search site}%q

Since %q is highlighted text as well it allows you to search the search engine of your choosing using selected text. I don't know about you but that's been something I wanted for a while, Chrome only lets you search the default search engine with highlighted text if you right click.

I also tossed in the benefit of choosing where your results open dynamically (that's what the w, t, c thing is talking about after the %e). If you type in a w at the end of your search text it will open the result in a little popup window, a t opens it in a new tab and a c (or nothing) opens it in the current tab.

The only kind of annoying part is if your search engine url has '%s' anywhere in it, chrome won't let search with no search text (can't just type the keyword and press enter). So if you just want to search on selected text you must use one of the w, t, or c keywords, it won't get added to your selected text for the search but it will make chrome think you are searching for something.

Instruction Note: I put instructions with the fiddle for packing the js and such, the only other thing I'd add is it seems jsFiddle is not friendly to copy and paste. It adds an extraneous, illegal invisible character to the end. If you paste it into notepad first you can delete the character (it will look like a ?) and then it should be fine.

*** TODO add the portage 'doc' USE variable?

apparently this causes circular dependencies if you do it on a global basis and should be added package by package.

*** TODO cut out dependencies on stuff like perl and python

first, translate these into something useful

https://code.google.com/p/yjl/source/browse/Miscellaneous/PDepGraph.py
http://yjl.googlecode.com/hg/Miscellaneous/PDepGraph.py

*** TODO remove all text editors other than emacs
*** TODO automate build process
*** TODO always use UTC.
*** TODO is lispy audio is a reasonable thing to ask for?
**** codebases to review

- pocket sphinx
- sphinx2
- sphinx3
- sphinxbase
- cl-pulseaudio

*** TODO hardware known to work

#+BEGIN_SRC common-lisp
(defvar *compatible-hardware*
'("Compaq Presario CQ57" (:x11-drivers '("x11-drivers/xf86-video-intel")
	    :make-conf "VIDEO_CARDS=\"intel\"")
  "Dell Precision M4400")
"This should be formalized into a list of enemies - ie, make the most
automated script possible to determine hardware -> drivers mapping and then
identify non-conformant chips, the companies behind them and email every
employee and every public email address for the company with a list of
demands. specifically demand LISP formatted hardware -> driver mappings +
requests to open source drivers & microcode. The obvious benefit of having
such a list being that you can *gasp* run a program on your computer that will
tell you if masamune will work, which AFIAK no Linux distribution has today.

NixOS automatically determines drivers somewhere in the kernel modules. How
does Ubuntu approach it?")
#+END_SRC

*** TODO unify compression format
    
Portage uses several compression formats without explaining why. Identify a /single/ compression format that will work for all code packages & documentation and use that instead.

*** TODO bind the debugger in all threads, currently errors get nesed up to sb-kernel:*maximum-error-depth*, causing problems when I attempt to join an IRC channel
*** TODO editor

see https://github.com/capitaomorte/sly for a rethinking of SLIME+SWANK. In the new Lisp editor there are a few things that are needed out of the box we don't have today in anything else.
persistant, cl-ppcre searchable rings, slime eval, eval in frame etc. that (possibly) specializes on the place in the 'global-tree' of such things.
keep track of all undefined functions etc. within the program even when the sexp is compiled
keep track of "" matching within strings?
with-open-file autocompletion (ie, just give me a stream name and complete symbols - can other forms use type inference to determine intermediate symbol names? I generally don't care much what they're called)
full english / todo editing integrated into the comments
index all codebases loaded into the lisp image for commands like `who-calls'
detect invalid lambda-lists
testing out of the box + stats on what is untested & tested
apropos (cl-ppcre regex)
smart updates of packages and .asd files according to your exports at the repl
better autodocs
autocompletion everywhere that works across packages (ie, pathnames, names should complete in both repl and buffers)
class browser (show methods of class etc.)
structure editing as the default
multiple repls
repl into other boxes works out of the box
autcompletion on common forms, defclass, etc. (redshank style?)
disassembler
better inspector - if I've a image / video / audio on one of my objects I should see it (obviously, resize etc.)
renaming files should update the .asd and also take care of any documentation references.
smart renaming mechanisms, smart argument list changes- notify me what else needs to be updated when I update a function -- this should carry through to the documentation of the codebase
a few 'flavors' of asdf-compiling a system, that is, I want to have some settings ranging from "fast" "debuggable" and be
able to compile a single system as such and get stats on how it works.

*** TODO Removing OpenGL

I'm not the first to notice OpenGL's problems, but am the first person I'm aware of stating that the lack of a realistic plan to address them is unacceptable.[1] A comprehensible open source 3D api is necessary for interesting programs of all kinds, and the medical and scientific establishments don't have access to anything better than a muppet with a netbook. Were current hardware properly documented, creating a replacement would be straightforward. Alas, we live in a world where market leaders compensate for technical incompetence by withholding information from their customers. Alternative computer architectures could present solutions for this in the medium to long term[2], but this does not address the need for a stable 3D api today. A sane api could be built on OpenGL, but there are issues. Consider:

1. The documentation for OpenGL is either poorly written, non-existent or so outdated that it actually manages to destroy understanding. the red book claims to contain the information necessary to write "modern OpenGL" but is little more than a poorly written scam to drain desperate programmers of their precious time and money. Very few programs require more than docstrings and perhaps a single document containing the vocabulary necessary to discuss the conceptual territory. in any case, the common lisp hyperspec clearly demonstrates that large programs can be adequately documented online - no book required.

2. OpenGL is entirely dependent on the the underlying hardware, and there are numerous issues at this level of abstraction. In the 22 years since it's inception no one has created an open source program to inform you as to which features are available on your computer, vendors regularly ignore bug reports, disregard the specification[3] and the hardware doesn't necessarily work as advertised either[4].

3. GLSL. It has syntax of C and none of the semantics, the language specification is a joke and as designed, there are serious performance issues.[5] There is no reason for it to exist and it needs to die.

4. The surrounding ecosystem is intellectually bankrupt. OpenGLUT, SDL and X may not be part of OpenGL, but they're necessary for using it. All are broken in various ways.[6] EG, when running some cl-opengl examples that make use of glut, if you press a key, with the glut window focused, it'll throw an error, and cause repaint errors (at the X level? screenshot: http://i.imgur.com/A2lY4zn.png) I realize that by abstracting over the debugging system of X, OpenGL and glut with the CL condition system, it's possible to have a sane development experience, but as far as i know no one has done this. The idiots who write SDL/GLUT/X etc. are perfectly happy to live with this defectiveness, but it wastes a massive amount of time of anyone who wishes to build even mildly sophisticated programs.

[[https://github.com/cbaggers/cepl][CEPL,]] [[https://github.com/cbaggers/varjo][varjo]] and [[https://github.com/3b/cl-opengl][cl-opengl]] are massive steps forwards towards a first-class common lisp 3D development system, However, having read some of the code and the included notes, I did not get the impression that the endgame for any of these projects includes addressing any of the above problems.

There are three sane ways I see to attack this problem:

1. Ignore 3D
   
2. Abstract over OpenGL. Anyway this is done it is going to be hellish to interface with due to the lack of documentation and lack of tests. The easiest way to approach this problem would be to identify a set of hardware that gets high enough OpenGL performance and is well supported by open source drivers, SBCL & a few other CL compilers. A specific version of OpenGLX should be chosen as the reference implementation and completely abstracted over in a programmatic fashion using the XML versions of the spec.
   
https://cvs.khronos.org/svn/repos/ogl/trunk/doc/registry/public/api/wgl.xml
https://cvs.khronos.org/svn/repos/ogl/trunk/doc/registry/public/api/gl.xml
https://cvs.khronos.org/svn/repos/ogl/trunk/doc/registry/public/api/glx.xml
https://cvs.khronos.org/svn/repos/ogl/trunk/doc/registry/public/api/readme.pdf

In the process the linux graphics stack should be cleaned up by tossing out any code that one can get rid of:

http://libv.livejournal.com/22502.html

http://blog.mecheye.net/2012/06/the-linux-graphics-stack/

When this is completed, build a test farm adding in new hardware and verifying that they pass the same test suite as the original hardware. Publish a list of non-compliant chips and mail to the parties responsible for not conforming to the standard.
   
3. Write a sane 3D api that ignores GPU acceleration entirely. Such a codebase could be actually understood (as you're not hacking around undocumented hardware) and re-write the relevant bits  if hardware acceleration ever makes itself available. This will result in the most lispy codebase as the abstractions will carry down to the metal. I don't know what sort of speed you could get by removing all of X, OpenGL and writing inline ASM, but suspect that it would be much faster than the pile of crud we've got today.

*** TODO removing X

X needs to go. I've taken a hard look at wayland and don't think it has much of a future.

relevent codebases,

https://github.com/pyb/zen
http://www.cliki.net/CLX-CURSOR
http://www.cliki.net/CLX-TRUETYPE
http://xcb.freedesktop.org/XmlXcb/
[[http://www.cliki.net/Acclaim][drawings directly on the screen using CLX]]
http://www.cliki.net/CL-VECTORS
[[http://users.actrix.co.nz/mycroft/event.lisp][CLX events]]
[[http://common-lisp.net/project/cmucl/doc/clx/][CLX manual]]
[[http://www.cawtech.demon.co.uk/clx/simple/examples.html][tutorial of using CLX]]
[[https://github.com/filonenko-mikhail/clx-xkeyboard][If we could get rid of the X keyboard system entirely that would be great.]]

*** TODO habits

   - race ghost
   - day/week/month/year note taking
      
*** TODO PCLOS

   there are two types of persistent classes that need to be taken into
   account. human readable and not. source files, such as packages.lisp and .asd
   files should be the human readable version. manardb deals with
   machine-redable objects, but the other side of this is lacking.

*** TODO removing Emacs

   Emacs is currently kept around to perform the following tasks

   - reading info files
     
   - Magit
     
     At some point in time someone sane will get fed up with git and write a
     CL-aware alternative, but until then we're stuck with Magit.

   - reading pdfs
     
     I don't plan on spending much of my time reading .pdfs in the future, but
     when the need arises (converting an idea in some paper to a vertex in the
     knowledge map) it will be nice to have Emacs around.

     the docview program for Emacs converts .pdfs into .png files for
     viewing. one could conceivably use ~cl-pdf to get in the case of
     obfuscation fall back onto a batch-mode emacs script to convert into .png
     for an ocr program (then output formatted the same as the .pdf using
     `format' hacks).
     
   replacing it with Climacs would be wonderful.

*** TODO advice system

- translate advice.el
- http://www.lispworks.com/documentation/lw445/LWRM/html/lwref-268.htm
- http://www.cs.cmu.edu/afs/cs/project/clisp/hackers/phg/clim/src/utils/clos-patches.lisp

*** TODO Read and extract design docs

   http://lists.unlambda.com/
   http://xach.com/naggum/articles/2004-031-ATW-KL2065E@naggum.no.html
   https://groups.google.com/forum/#!topic/comp.lang.lisp/AhXjZBHFoQU%5B1-25-false%5D
   https://groups.google.com/forum/#!topic/comp.lang.lisp/McM5qzmIWS4%5B1-25-false%5D
   https://groups.google.com/forum/message/raw?msg=comp.lang.lisp/XpvUwF2xKbk/Xz4Mww0ZwLIJ
   https://groups.google.com/forum/#!msg/comp.lang.dylan/3uuUb3Z9pAc/6NbE9gYpeAIJ
   
** Glossary

I'm unfamiliar with UNIX jargon and so shall be using my own set of definitions until I have the chance to unify this set of ideas into a single cohesive whole.

cripple mode: the 'state' your computer is in when you are forced to compute without X or any sort of graphical interface and are forced to move up and down pages with Control-Shift-Page-Up/Down and switch though "virtual terminals" or something with an equally obtuse keybinding. I believe this is known as console mode in UNIX.

compute mode: the 'state' your computer is in when the full Masamune graphical environment & associated tooling is running.

The problem with cripple mode currently is that you cannot explore it, there is no documentation on how it works and the only way to learn what its capabilities are is by osmosis, where someone in the know says "Oh yeah, to change through virtual terminals do <keybinding>".

The correct way to address the situation is to:

0. when the user is first dropped into cripple mode, query as to the keyboard to be used: dvorak, colemak and language if appropriate.

1. ensure that a modern Emacs with SLIME and a CL compiler are available.

2. document in some fashion (probably info pages) all of the things that you can possibly do in this mode.

3. when the user is dropped into cripple mode for some reason, list all possible commands and promt them to assign them to keys and show them where the documentation describing cripple mode is while within emacs.

Now that i think about it, with or without X there should be a single way of configuring your keys. This is stupid.

#+BEGIN_SRC

(defun cripple-mode-console-colemak ()
  "I have nfi idea why this works"
  (interactive)
  (save-window-excursion 
    (find-file "/tmp/caps-to-control.map")
    (with-current-buffer "caps-to-control.map"
      (erase-buffer)
      (insert 
       "keycode 58 = Control\n"
       "alt_is_meta\n"
       (shell-command-to-string "dumpkeys | head -1"))
       (save-buffer)))
  (shell-command-to-string "loadkeys /usr/share/keymaps/i386/colemak/en-latin9.map.gz")
  (shell-command-to-string "loadkeys /tmp/caps-to-control.map"))

(defun network ()
 (interactive)
 ;; run nmtui in another virtual terminal so as to make use of ncurses
 )

#+END_SRC

* Research
** academic research papers

synthesis OS

** Review of Related technologies
*** ankisrs.net
**** pros
**** cons
*** Knewton
**** pros
**** cons

Their product is currently not (and will never be?) open to the public. Thus it has no future.

*** Khan Academy
**** pros   
**** cons

- there is far too much going on visually.

- I'm not entirely sold on the idea of hints - generally speaking, you either
  understand something, or not. It's not as if seeing a 'hint' (part of the
  solution) is going to jump start your brain into understanding. If I don't
  understand show exactly how the solution was derived and call it "show
  solution". Renaming it to 'hint' is dishonest.

- It's rather irritating that I can't sign up for a course / lesson / path and resume where I left off.
     
- Not personalized enough - when it knows the language I use and other such settings.
     
- resource intensive - slow, causes chrome to crash
     
- The concepts they teach are all relatively sophomoric. 
     
- doesn't allow for mastery, as in, it's a technology that punishes experts.
     
- there isn't a clear flow when practicing skills
     
- Overload of points and notifications / badges, and it's not clear what they represent, or what their value is.
     
- the community page is far too cluttered
     
- on the 'mission' page there is far too much going on. You really only need one progress bar.
     
- Logos suck
     
- There isn't a GO button, or any clear way to quickly set off from what you were last learning.
     
- Okay, yes, the UI is friendly, but it's also insulting to my intelligence. Where are my options, settings etc?
     
- HTML5 back button doesn't work like you would expect
     
- slow
     
- Problems should fit on the screen

- I can scroll down when I'm in the middle of solving problems. Irritating, especially since there isn't anything there.
	  
- If I get something correct, automatically move me onto the next problem
     
- When I get to the end of a task and see the task dashboard, there isn't a 'continue' button. This breaks my flow.
     
- the graphs / dashboard visualizations don't fit together to form a coherent whole. How much have I learned of the subject, course, mission? I've nfi. What is the purpose of the metrics you're showing me?

- I want an introduction to the concepts used to structure information within their app, but nothing is available. I know what a coach is irl, but no idea what it means on your system.

- it's not clear where to get started if I want to learn something new or spend my time browsing around - probably b/c the concepts are not clearly defined.
      
*** clever
**** pros
**** cons
*** EdX
**** pros
**** cons
*** Coursera
**** pros
**** cons
*** brilliant.org
**** pros
**** cons
*** quizlet
**** pros
**** cons

- Slow

* Footnotes

[1] examples of people completely failing to offer realistic solutions:

#+BEGIN_SRC
(dolist (k '("http://www.joshbarczak.com/blog/?p=99"                
             "http://richg42.blogspot.com/2014/05/things-that-drive-me-nuts-about-opengl.html"
             "http://richg42.blogspot.com/2014/06/how-i-learned-to-stop-worrying-and-love.html"
             "http://timothylottes.blogspot.se/2014/05/re-joshua-barczaks-opengl-is-broken.html"
             "http://www.joshbarczak.com/blog/?p=196"))
 (mmb::open-uri k))
#+END_SRC

[2] http://www.loper-os.org/?p=1361
[3] http://richg42.blogspot.com/2014/05/the-truth-on-opengl-driver-quality.html
[4] https://dolphin-emu.org/blog/2013/09/26/dolphin-emulator-and-opengl-drivers-hall-fameshame/
[5] http://www.joshbarczak.com/blog/?p=154

See reason #3. The author takes the position of "no one could have predicted that putting a compiler in the driver was a bad idea". This is obviously false. Anyone thinking about the design for a day or so would realized that this is a terrible idea.

[6] how we got here. I read this book and found it informative and entertaining: http://richard.esplins.org/static/downloads/unix-haters-handbook.pdf
